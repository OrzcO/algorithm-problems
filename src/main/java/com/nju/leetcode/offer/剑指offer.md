## hash
- num >> 1 是num除2，而不是除10

Pro 3 ==>> 简单hash，第二种方法。
Pro 4 ==>> 简单查找，二维数组查找。
Pro 5 ==>> 字符串空格转化为%20，第二种方法。
Pro 6 ==>> 链表逆序返回[]
Pro 7 ==>> 先序中序递归构建二叉树，第二种方法
Pro 9 ==>> 两个栈实现一个队列
Pro 10-1,10-2 ==>> Fibonacci问题
Pro 11 ==>> 特殊数组输出最小值 可能有技巧
Pro 12 ==>> 搜索，深度优先  可以连代码 50行左右，标准搜索题
Pro 13 ==>> 搜索，dfs/bfs 其中dfs为啥不能往上走证明，以及bfs做法
Pro 14_1 ==>> 贪心，可以用余数 + pow进行简化代码，避免递归逻辑；可以用dp来做，但明显不是最优解
Pro 14_2 ==>> 贪心，只是数据变大了，加上取模操作，不能用Math.pow来快速解决，逻辑不变
Pro 15 ==>> 位运算，比较考验技巧。 两种做法都可以回顾一下
Pro 16 ==>> 快速幂，经典题目，还有int[]范围的坑，用long做中间转换一下，防止溢出
Pro 17 ==>> 简单生成一个数组
Pro 18 ==>> 链表删除节点
Pro 19 ==>> 正则匹配题，可以用递归写，也可以用dp[]进行优化,难题（dp做法再考虑下
Pro 21 ==>> 数组调整，类似快排的思路，attention.
Pro 22 ==>> 链表求倒数第n个节点。 有链表技巧。
Pro 24 ==>> 链表逆序，也是链表技巧

Pro 27 ==>> 二叉树镜像翻转
Pro 28 ==>> 判断二叉树是否镜像，递归即可
Pro 29 ==>> 循环/递归，考验代码能力以及coding速度
Pro 30 ==>> 最小栈，保证取出最小值、push、pop都是O(1)  | 可以有优化，最简单做法不是每次pop都pop两次栈
Pro 31 ==>> 栈操作，判断出栈顺序是否合理； | 可以用int[] + idx代替栈；以及O(1)的空间复杂度的做法；√
Pro 32_1 ==>> 层次遍历树
Pro 32_2 ==>> 层次遍历树 | 可以用dfs来做！！！
Pro 32_3 ==>> 层次遍历树，奇数行正序，偶数行逆序，√ | 还可以用dfs来做
Pro 33 ==>> 判断数组是不是二叉树的后续遍历  √ | good
Pro 34 ==>> 求树中路径和为指定sum的所有路径。 dfs | 可以优化代码，全局共用一个list
Pro 35 ==>> 深度复制链表，带random和next，hash的思路来做的 | 好像还有一种链式的思路没看

-------
java的三种位移运算：
- <<  :     左移运算符，num << 1,相当于num乘以2
- >>  :     右移运算符，num >> 1,相当于num除以2
- >>> :     无符号右移，忽略符号位，空位都以0补齐
--------
强烈安利： 
Arrays.copyOfRange(int[] arr, int l, int r)   代表arr[l, r-1] 范围内数组会copy出一份
l , r 都是 0<= <=arr.length-1 有效的数组下标范围内，